//////////////////////////////////////////////////////////////////////////////
// Model: dpp.qm
// File:  ./table.cpp
//
// This file has been generated automatically by QP Modeler (QM).
// DO NOT EDIT THIS FILE MANUALLY.
//
// Please visit www.state-machine.com/qm for more information.
//////////////////////////////////////////////////////////////////////////////
#include "qp_port.h"
#include "dpp.h"
#include "bsp.h"

Q_DEFINE_THIS_FILE

/* Active object class -----------------------------------------------------*/
// @(/2/1) ...................................................................
class Table : public QActive {
private:
    uint8_t m_fork[N_PHILO];
    uint8_t m_isHungry[N_PHILO];

public:
    Table();

protected:
    static QState initial(Table *me, QEvent const *e);
    static QState serving(Table *me, QEvent const *e);
};

#define RIGHT(n_) ((uint8_t)(((n_) + (N_PHILO - 1)) % N_PHILO))
#define LEFT(n_)  ((uint8_t)(((n_) + 1) % N_PHILO))
enum ForkState { FREE, USED };

/* Local objects -----------------------------------------------------------*/
static Table l_table;     /* the single instance of the Table active object */

/* Global-scope objects ----------------------------------------------------*/
QActive * const AO_Table = (QActive *)&l_table;      /* "opaque" AO pointer */

/*..........................................................................*/
// @(/2/1) ...................................................................
// @(/2/1/2) .................................................................
Table::Table() : QActive((QStateHandler)&Table::initial) {
    for (uint8_t n = 0; n < N_PHILO; ++n) {
        m_fork[n] = FREE;
        m_isHungry[n] = 0;
    }
}
// @(/2/1/3) .................................................................
// @(/2/1/3/0)
QState Table::initial(Table *me, QEvent const *e) {
    (void)e; // suppress the compiler warning about unused parameter

    QS_OBJ_DICTIONARY(&l_table);
    QS_FUN_DICTIONARY(&QHsm::top);
    QS_FUN_DICTIONARY(&Table::initial);
    QS_FUN_DICTIONARY(&Table::serving);

    QS_SIG_DICTIONARY(DONE_SIG,      0); // global signals
    QS_SIG_DICTIONARY(EAT_SIG,       0);
    QS_SIG_DICTIONARY(TERMINATE_SIG, 0);

    QS_SIG_DICTIONARY(HUNGRY_SIG,    me); // signal just for Table

    me->subscribe(DONE_SIG);
    me->subscribe(TERMINATE_SIG);
    return Q_TRAN(&Table::serving);
}
// @(/2/1/3/1) ...............................................................
QState Table::serving(Table *me, QEvent const *e) {
    switch (e->sig) {
        // @(/2/1/3/1/0)
        case HUNGRY_SIG: {
            BSP_busyDelay();
            uint8_t n = ((TableEvt const *)e)->philoNum;
            // phil ID must be in range and he must be not hungry
            Q_ASSERT((n < N_PHILO) && (!me->m_isHungry[n]));

            BSP_displyPhilStat(n, "hungry  ");
            uint8_t m = LEFT(n);
            // @(/2/1/3/1/0/0)
            if ((me->m_fork[m] == FREE) && (me->m_fork[n] == FREE)) {
                me->m_fork[m] = me->m_fork[n] = USED;
                TableEvt *pe = Q_NEW(TableEvt, EAT_SIG);
                pe->philoNum = n;
                QF::PUBLISH(pe, me);
                BSP_displyPhilStat(n, "eating  ");
                return Q_HANDLED();
            }
            // @(/2/1/3/1/0/1)
            else {
                me->m_isHungry[n] = 1;
                return Q_HANDLED();
            }
        }
        // @(/2/1/3/1/1)
        case DONE_SIG: {
            uint8_t n, m;
            TableEvt *pe;

            BSP_busyDelay();
            n = ((TableEvt const *)e)->philoNum;
            // phil ID must be in range and he must be not hungry
            Q_ASSERT((n < N_PHILO) && (!me->m_isHungry[n]));

            BSP_displyPhilStat(n, "thinking");
            m = LEFT(n);
            // both forks of Phil[n] must be used
            Q_ASSERT((me->m_fork[n] == USED) && (me->m_fork[m] == USED));

            me->m_fork[m] = me->m_fork[n] = FREE;
            m = RIGHT(n); // check the right neighbor

            if (me->m_isHungry[m] && (me->m_fork[m] == FREE)) {
                me->m_fork[n] = me->m_fork[m] = USED;
                me->m_isHungry[m] = 0;
                pe = Q_NEW(TableEvt, EAT_SIG);
                pe->philoNum = m;
                QF::PUBLISH(pe, me);
                BSP_displyPhilStat(m, "eating  ");
            }
            m = LEFT(n); // check the left neighbor
            n = LEFT(m); // left fork of the left neighbor
            if (me->m_isHungry[m] && (me->m_fork[n] == FREE)) {
                me->m_fork[m] = me->m_fork[n] = USED;
                me->m_isHungry[m] = 0;
                pe = Q_NEW(TableEvt, EAT_SIG);
                pe->philoNum = m;
                QF::PUBLISH(pe, me);
                BSP_displyPhilStat(m, "eating  ");
            }
            return Q_HANDLED();
        }
        // @(/2/1/3/1/2)
        case TERMINATE_SIG: {
            QF::stop();
            return Q_HANDLED();
        }
        // @(/2/1/3/1/3)
        case EAT_SIG: {
            Q_ERROR();
            return Q_HANDLED();
        }
    }
    return Q_SUPER(&QHsm::top);
}

