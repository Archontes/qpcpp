//////////////////////////////////////////////////////////////////////////////
// Model: test0.qm
// File:  ./test0.cpp
//
// This file has been generated automatically by QP Modeler (QM).
// DO NOT EDIT THIS FILE MANUALLY.
//
// Please visit www.state-machine.com/qm for more information.
//////////////////////////////////////////////////////////////////////////////
/*
Performance test0:

This performance test uses one state machine Test0, which processes PING events.
Upon receiving each PING event, the Test0 state machine increments an internal
counter m_counter.

Also, the PING events drive transitions between the "on" and "off" states, which
turn an LED on and off, respectively.

The test runs on the EV-LM3S811 ARM Cortex-M3 board, with CPU clock configured
for 20MHz.

The SysTick interrupt, which is driven from the CPU clock, is set for 10 million
cycles (1/2 second).

The test is indended to be run in a debugger, with a breakpoint inside the
SysTick ISR. The l_test.m_counter variable should be watched. The m_count
difference between successive SysTicks represents the number of processed
PING events over the 10 million cycles.

Processing of each event tests the performance of the following QP elements:

1. event dispatching to the Test state machine
2. event processing inside the state machine
*/

#include "qp_port.h"
#include "lm3s_cmsis.h"

// set ticking rate to 2 times per second, which is every 10million
// CPU cycles at 20 MHz
#define BSP_TICKS_PER_SEC  2U

#define USER_LED           (1U << 5)

namespace TEST {

//Q_DEFINE_THIS_FILE

void BSP_init(void);
void BSP_ledOn(void);
void BSP_ledOff(void);

//............................................................................
extern "C" void SysTick_Handler(void) {
}

//............................................................................
void BSP_init(void) {
    // set the system clock as specified in lm3s_config.h (20MHz from PLL)
    SystemInit();

    // enable clock to the peripherals used by the application
    SYSCTL->RCGC2 |= (1U << 2);              // enable clock to C
    __NOP();                                 // wait after enabling clocks

    // configure the LED
    GPIOC->DIR |= USER_LED;                  // set direction: output
    GPIOC->DEN |= USER_LED;                  // digital enable
    GPIOC->DATA_Bits[USER_LED] = 0U;         // turn the User LED off

    // set up the SysTick timer to fire at BSP_TICKS_PER_SEC rate
    (void)SysTick_Config(SystemFrequency / BSP_TICKS_PER_SEC);
}
//............................................................................
void BSP_ledOn(void) {
    GPIOC->DATA_Bits[USER_LED] = USER_LED;
}
//............................................................................
void BSP_ledOff(void) {
    GPIOC->DATA_Bits[USER_LED] = 0U;
}
//............................................................................
extern "C" void Q_onAssert(char_t const * const, int_t const) {
    QF_INT_DISABLE(); // make sure that all interrupts are disabled
    for (;;) {        // NOTE: replace the loop with reset for final version
    }
}

// Active object class -------------------------------------------------------
enum TestSignals {
    PING_SIG = QP::Q_USER_SIG,
    MAX_PUB_SIG,  // the last published signal
    MAX_SIG       // the last signal
};

// Test active object --------------------------------------------------------
// @(/1/0) ...................................................................
class Test0 : public QP::QHsm {
public:
    /// ping counter
    uint32_t m_counter;

public:
    Test0();

protected:
    static QP::QState initial(Test0 * const me, QP::QEvt const * const e);
    static QP::QState on(Test0 * const me, QP::QEvt const * const e);
    static QP::QState off(Test0 * const me, QP::QEvt const * const e);
};
// @(/1/0) ...................................................................
// @(/1/0/1) .................................................................
Test0::Test0() 
  : QHsm(Q_STATE_CAST(&Test0::initial))
{
}

// @(/1/0/2) .................................................................
// @(/1/0/2/0)
QP::QState Test0::initial(Test0 * const me, QP::QEvt const * const e) {
    (void)e; // suppress the compiler warning about unused parameter
    me->m_counter = 0U;
    return Q_TRAN(&Test0::on);
}
// @(/1/0/2/1) ...............................................................
QP::QState Test0::on(Test0 * const me, QP::QEvt const * const e) {
    QP::QState status;
    switch (e->sig) {
        // @(/1/0/2/1)
        case Q_ENTRY_SIG: {
            BSP_ledOn();
            status = Q_HANDLED();
            break;
        }
        // @(/1/0/2/1/0)
        case PING_SIG: {
            ++me->m_counter;
            status = Q_TRAN(&Test0::off);
            break;
        }
        default: {
            status = Q_SUPER(&QHsm::top);
            break;
        }
    }
    return status;
}
// @(/1/0/2/2) ...............................................................
QP::QState Test0::off(Test0 * const me, QP::QEvt const * const e) {
    QP::QState status;
    switch (e->sig) {
        // @(/1/0/2/2)
        case Q_ENTRY_SIG: {
            BSP_ledOff();
            status = Q_HANDLED();
            break;
        }
        // @(/1/0/2/2/0)
        case PING_SIG: {
            ++me->m_counter;
            status = Q_TRAN(&Test0::on);
            break;
        }
        default: {
            status = Q_SUPER(&QHsm::top);
            break;
        }
    }
    return status;
}


static Test0 l_test0;   // storage for the Test0 HSM

extern "C" void main(void) {

    BSP_init(); // initialize the BSP

    l_test0.init(); // take the top-most initial transition

    static QP::QEvt const pingEvt = { PING_SIG, 0U, 0U };
    while (1) {
        l_test0.dispatch(&pingEvt);
    }
}

} // namespace TEST

