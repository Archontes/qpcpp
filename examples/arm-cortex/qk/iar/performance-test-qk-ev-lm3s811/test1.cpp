//////////////////////////////////////////////////////////////////////////////
// Model: test1.qm
// File:  ./test1.cpp
//
// This file has been generated automatically by QP Modeler (QM).
// DO NOT EDIT THIS FILE MANUALLY.
//
// Please visit www.state-machine.com/qm for more information.
//////////////////////////////////////////////////////////////////////////////
#include "qp_port.h"
#include "lm3s_cmsis.h"
/*
Performance test:

This performance test uses one active object Test, which posts the PING
event to self upon receiving a PING event.

Upon receiving each PING event, the Test active object increments an
internal counter m_counter.

Also, the PING events drive transitions between the "on" and "off" states,
which turn an LED on and off, respectively.

The test runs on the EV-LM3S811 ARM Cortex-M3 board, with CPU clock
configured for 20MHz.

The SysTick interrupt, which is driven from the CPU clock, is set for
10 million cycles (1/2 second).

The test is indended to be run in a debugger, with a breakpoint inside
the SysTick ISR. The l_test.m_counter variable should be watched. The
count difference between successive SysTicks represents the number of
the processed PING events over the 10 million cycles.

Processing of each event tests the performance of the following QP
elements:

1. dynamic event generation (if the macro DYN_QEVT is defined)
2. event posting
3. event queueing
4. event dispatching to the Test state machine
5. event processing inside the state machine
6. event recycling
7. the QK scheduler

*/

#define BSP_TICKS_PER_SEC  2U
#define USER_LED           (1U << 5)

namespace TEST {

//Q_DEFINE_THIS_FILE

void BSP_init(void);
void BSP_ledOn(void);
void BSP_ledOff(void);

//............................................................................
extern "C" void SysTick_Handler(void) {
    QK_ISR_ENTRY();           // inform QK about entering an ISR
    QP::QF::TICK((void *)0);  // process all armed time events
    QK_ISR_EXIT();            // inform QK about exiting an ISR
}

//............................................................................
void BSP_init(void) {
    // set the system clock as specified in lm3s_config.h (20MHz from PLL)
    SystemInit();

    // enable clock to the peripherals used by the application
    SYSCTL->RCGC2 |= (1U << 2);              // enable clock to C
    __NOP();                                 // wait after enabling clocks

    // configure the LED and push button
    GPIOC->DIR |= USER_LED;                  // set direction: output
    GPIOC->DEN |= USER_LED;                  // digital enable
    GPIOC->DATA_Bits[USER_LED] = 0U;         // turn the User LED off
}
//............................................................................
void BSP_ledOn(void) {
    GPIOC->DATA_Bits[USER_LED] = USER_LED;
}
//............................................................................
void BSP_ledOff(void) {
    GPIOC->DATA_Bits[USER_LED] = 0U;
}
//............................................................................
extern "C" void Q_onAssert(char_t const * const, int_t const) {
    QF_INT_DISABLE(); // make sure that all interrupts are disabled
    for (;;) {        // NOTE: replace the loop with reset for final version
    }
}

// Active object class -------------------------------------------------------
enum TestSignals {
    PING_SIG = QP::Q_USER_SIG,
    MAX_PUB_SIG,  // the last published signal
    MAX_SIG       // the last signal
};

// Test active object --------------------------------------------------------
// @(/1/0) ...................................................................
class Test1 : public QP::QActive {
public:
    /// ping counter
    uint32_t m_counter;
    QP::QTimeEvt m_timeEvt;

public:
    Test1();

protected:
    static QP::QState initial(Test1 * const me, QP::QEvt const * const e);
    static QP::QState on(Test1 * const me, QP::QEvt const * const e);
    static QP::QState off(Test1 * const me, QP::QEvt const * const e);
};
// @(/1/0) ...................................................................
// @(/1/0/2) .................................................................
Test1::Test1() 
  : QActive(Q_STATE_CAST(&Test1::initial)),
    m_timeEvt(PING_SIG)
{
}

// @(/1/0/3) .................................................................
// @(/1/0/3/0)
QP::QState Test1::initial(Test1 * const me, QP::QEvt const * const e) {
    (void)e; // suppress the compiler warning about unused parameter
    me->m_counter = 0U;
    me->m_timeEvt.postIn(me, 1U);
    return Q_TRAN(&Test1::on);
}
// @(/1/0/3/1) ...............................................................
QP::QState Test1::on(Test1 * const me, QP::QEvt const * const e) {
    QP::QState status;
    switch (e->sig) {
        // @(/1/0/3/1)
        case Q_ENTRY_SIG: {
            BSP_ledOn();
            status = Q_HANDLED();
            break;
        }
        // @(/1/0/3/1/0)
        case PING_SIG: {
            ++me->m_counter;

            #ifdef DYN_QEVT
            me->POST(Q_NEW(QP::QEvt, PING_SIG), me);
            #else
            static QP::QEvt const ping = { PING_SIG, 0U, 0U };
            me->POST(&ping, me);
            #endif
            status = Q_TRAN(&Test1::off);
            break;
        }
        default: {
            status = Q_SUPER(&QHsm::top);
            break;
        }
    }
    return status;
}
// @(/1/0/3/2) ...............................................................
QP::QState Test1::off(Test1 * const me, QP::QEvt const * const e) {
    QP::QState status;
    switch (e->sig) {
        // @(/1/0/3/2)
        case Q_ENTRY_SIG: {
            BSP_ledOff();
            status = Q_HANDLED();
            break;
        }
        // @(/1/0/3/2/0)
        case PING_SIG: {
            ++me->m_counter;

            #ifdef DYN_QEVT
            me->POST(Q_NEW(QP::QEvt, PING_SIG), me);
            #else
            static QP::QEvt const ping = { PING_SIG, 0U, 0U };
            me->POST(&ping, me);
            #endif
            status = Q_TRAN(&Test1::on);
            break;
        }
        default: {
            status = Q_SUPER(&QHsm::top);
            break;
        }
    }
    return status;
}


static Test1 l_test1;   // storage for the Test1 AO

extern "C" int_t main(void) {
    static QP::QEvt const *testQueueSto[10];
    static QP::QSubscrList subscrSto[MAX_PUB_SIG];
    static QF_MPOOL_EL(QP::QEvt) smlPoolSto[10]; // small pool

    QP::QF::init();   // initialize the framework and the underlying RT kernel

    BSP_init(); // initialize the BSP

    QP::QF::psInit(&subscrSto[0], Q_DIM(subscrSto)); // init publish-subscribe

    // initialize event pools...
    QP::QF::poolInit(&smlPoolSto[0], sizeof(smlPoolSto),
                                     sizeof(smlPoolSto[0]));

    // start the active objects...
    l_test1.start(1U,
                  &testQueueSto[0], Q_DIM(testQueueSto),
                  static_cast<void *>(0), 0U);


    return QP::QF::run(); // run the QF application
}

} // namespace TEST

// QP callbacks ==============================================================
namespace QP {

//............................................................................
void QF::onStartup(void) {
                 // set up the SysTick timer to fire at BSP_TICKS_PER_SEC rate
    (void)SysTick_Config(SystemFrequency / BSP_TICKS_PER_SEC);
}
//............................................................................
void QF::onCleanup(void) {
}
//............................................................................
void QK::onIdle(void) {
}

} // namespace QP

